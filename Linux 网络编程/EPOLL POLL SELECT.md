## epool 编程接口
`epoll`的优点：
- `epoll` 与 `select`，`poll`相比有更好的性能。
- `epoll` 支持水平触发(LT)和边缘(ET)触发两种模式，`select`和`poll`只支持水平触发，`信号驱动I/O`只支持边缘触发。
- 可以避免 `信号驱动I/O` 复杂的信号处理流程，同时也可以指定我们希望检查的事件（检查套接字文件描述符的读就 绪、写就绪或者两者同时指定）。



> 当我们通过 epoll_create() 创建一个 epoll 实例时，内核在内存中创建了一个新的 i-node 并打开文件描述，随后在调用进程中为打开的这个文件描述分配一个新的文件描述符。同 epoll 实例的兴趣列表相关联的是打开的文件描述，而不是 epoll 文件描述符。

✔️ 直译+理解：

- **epoll_create()**：在内核分配了一个 epoll 专用的 i-node 节点（它本质上是文件系统抽象出来的对象，内核用它来表示一切资源）
    
- 内核为这个 i-node 分配了一个**文件描述符（epfd）**
    
- 当你往 epoll 实例里加监听对象时，**兴趣列表存的是目标 fd（比如 sockfd）**
    
- **epoll 实例本身（epfd）只是一个管理句柄，不在兴趣列表内**






## 📌 1️⃣ 边缘触发 vs 水平触发

在 epoll 里有两种触发模式：

- **水平触发（Level Triggered, LT）**：默认，epoll_wait 检查到文件描述符就绪后，只要没读完/写完，下次 epoll_wait 还会继续通知
    
- **边缘触发（Edge Triggered, ET）**：只有当文件描述符状态**从未就绪到就绪时**才通知一次，之后不再通知，除非状态再次变化
    

ET 性能更高，但对程序员要求更高，因为如果这一次没有把数据“尽可能全读完”，后面就没通知了，容易丢事件。

---

## 📌 2️⃣ 边缘触发下的“饥饿”问题是啥？

设想你有多个 socket 在监听，突然其中一个（比如 client A）发了大量数据过来，是个不间断的流：

- **epoll_wait() 返回**，你看到 client A 的 fd 就绪了
    
- 你去读，但如果你在这一次循环里**一直忙着把 client A 的数据全读完**（非阻塞读到 EAGAIN 为止）
    
- 那么在这期间，其他的 socket（client B、client C）可能早就有事件，但你还没调度它们，就被 client A 占着 CPU 了
    

👉 这就是**文件描述符饥饿（starvation）**：

> 某些 fd 长时间得不到调度机会，因为有一个“霸占 CPU 的大户”。

---

## 📌 3️⃣ 常规解决方案

为了避免这种情况，常见做法是：

### ✅ 应用层自己维护一个“就绪队列”

- epoll_wait 检测到就绪的 fd，就放到你程序自己维护的队列里（比如 `std::vector<int> readyFds`）
    
- 每次 epoll_wait 的超时时间可以设置得很短，或者 0（非阻塞式），这样可以迅速检测是否有新事件，再返回来继续处理 ready 队列
    
- 轮转调度（round-robin）：ready 队列里的 fd 每次按顺序来，每个 fd 限定处理量（比如一次只处理 1000 字节）
    

### ✅ 当非阻塞 I/O 调用返回 EAGAIN/EWOULDBLOCK 时

- 表示这个 fd 暂时没有数据可读/写
    
- 就把这个 fd 从 ready 队列里移除
    
- 等下一轮 epoll_wait 检测到它重新变成就绪再放回来
    

👉 这样避免了一个 fd 长时间占用 CPU 的情况，实现了**公平调度**

---

## 📌 4️⃣ 额外好处：

因为你自己管理了就绪队列，就可以在这轮调度循环里：

- 顺便处理定时器（比如检查定时任务是否超时）
    
- 顺便用 `sigwaitinfo()` 等机制处理信号
    

也就是形成了一个统一的事件循环模型，类似 Muduo、libevent、libuv 里的那种 `EventLoop`。

---

## 📌 5️⃣ 信号驱动 I/O 同理

信号驱动 I/O（`SIGIO`）本质也是边缘触发：

- 当有事件时，信号触发
    
- 如果信号处理函数里没及时读完，也会有“丢事件”的风险
    
- 所以同样需要类似机制处理饥饿现象
    

---

## 📌 6️⃣ 水平触发（LT）就不用管这个？

是的。

- 因为 LT 模式下，只要 fd 上有未处理数据，下次 epoll_wait 一定会继续通知
    
- 即使你当前只读了 1 字节，下一次 epoll_wait 也会继续返回这个 fd
    
- 所以不存在“丢事件”或者“饥饿”问题，程序可以更随意、简单些，但开销和性能相对 ET 略低
    

---

## 📊 总结一句：

- **ET 性能高，但事件通知一次，程序必须尽快“吃干净”，否则容易“饥饿”**
    
- **自己维护 ready 队列 + 轮转调度 + 超时短 epoll_wait + EAGAIN/EWOULDBLOCK 判断，是常规解决方案**
    
- **LT 不用担心饥饿，但 epoll_wait 返回次数多、性能略逊**
    

---

如果你要我，我还能帮你画个结构图，或者写个简化版轮转调度的 C++ epoll 示例代码 👌，要不要？✨