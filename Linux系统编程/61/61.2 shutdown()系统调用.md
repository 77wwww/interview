`shutdown` 系统调用用于控制套接字的关闭行为，与直接调用 `close` 不同，它可以选择性地关闭套接字的读、写或读写通道，提供更精细的连接管理。以下是详细讲解：


### **一、基本概念**
#### 1. **函数原型**
```c
#include <sys/socket.h>

int shutdown(int sockfd, int how);
```
- **参数**：
  - `sockfd`：套接字描述符。
  - `how`：关闭方式，可选值：
    - `SHUT_RD`：关闭读通道（不再接收数据）。
    - `SHUT_WR`：关闭写通道（不再发送数据，发送缓冲区数据会被发送）。
    - `SHUT_RDWR`：同时关闭读写通道（等价于 `SHUT_RD` + `SHUT_WR`）。
- **返回值**：
  - 成功：返回 `0`。
  - 失败：返回 `-1`，并设置 `errno`（如 `EBADF`、`ENOTCONN` 等）。


### **二、与 `close` 的核心区别**
| **操作**       | **连接计数** | **读通道** | **写通道** | **发送缓冲区** | **示例场景**                     |
|----------------|--------------|------------|------------|----------------|----------------------------------|
| `close(sock)`  | 减1（为0时关闭） | 关闭       | 关闭       | 可能丢弃       | 完全终止连接                     |
| `shutdown(sock, SHUT_RD)` | 不变         | 关闭       | 保持开放   | 不受影响       | 停止接收数据，但继续发送响应     |
| `shutdown(sock, SHUT_WR)` | 不变         | 保持开放   | 关闭       | 数据会被发送   | 发送结束标记（如HTTP的 `Connection: close`） |
| `shutdown(sock, SHUT_RDWR)` | 不变      | 关闭       | 关闭       | 数据会被发送   | 优雅关闭（先发送剩余数据，再关闭） |


### **三、典型应用场景**
#### 1. **半关闭连接（Half-Close）**
- **场景**：一方需停止发送数据，但仍接收对方数据（如文件传输）。
- **示例**：
  ```c
  // 客户端发送完数据后关闭写通道
  shutdown(sockfd, SHUT_WR);
  
  // 继续接收服务器响应
  while ((n = recv(sockfd, buffer, sizeof(buffer), 0)) > 0) {
      // 处理响应
  }
  ```

#### 2. **优雅关闭（Graceful Shutdown）**
- **场景**：确保所有已发送数据被接收方处理。
- **步骤**：
  1. 调用 `shutdown(sockfd, SHUT_WR)` 通知对方“不再发送”。
  2. 继续接收对方数据，直到 `recv` 返回 `0`（对方也关闭）。
  3. 调用 `close(sockfd)` 完全关闭连接。

#### 3. **强制终止接收**
- **场景**：立即丢弃接收缓冲区数据，不再接收新数据。
  ```c
  shutdown(sockfd, SHUT_RD);  // 丢弃接收缓冲区数据
  ```


### **四、深入理解 `shutdown` 的行为**
#### 1. **关闭写通道（`SHUT_WR`）**
- 发送FIN包，表示“我不再发送数据”。
- 接收方 `recv` 返回 `0` 时，知道发送方已关闭写通道。
- 发送方仍可接收数据，直到对方也关闭写通道。

#### 2. **关闭读通道（`SHUT_RD`）**
- 丢弃接收缓冲区中所有数据。
- 后续调用 `recv` 直接返回 `-1`，`errno` 为 `ECONNRESET`。
- 常用于快速释放接收资源。

#### 3. **引用计数与多进程/多线程**
- `close` 减少套接字引用计数，计数为0时才真正关闭连接。
- `shutdown` 直接影响连接状态，与引用计数无关。
  ```c
  // 多线程示例：线程A关闭写，线程B仍可接收
  pthread_create(&tid, NULL, thread_recv, &sockfd);
  shutdown(sockfd, SHUT_WR);  // 线程A关闭写
  ```


### **五、常见错误与注意事项**
#### 1. **错误处理**
- `shutdown` 失败常见原因：
  - `EBADF`：无效的套接字描述符。
  - `ENOTCONN`：套接字未连接。
  - `ENOTSOCK`：参数不是套接字描述符。

#### 2. **与 `close` 的配合**
- **错误做法**：多次调用 `shutdown` 同一套接字。
  ```c
  shutdown(sockfd, SHUT_WR);
  shutdown(sockfd, SHUT_RD);  // 第二次调用可能失败
  ```
- **正确做法**：使用 `SHUT_RDWR` 一次关闭读写通道。

#### 3. **阻塞与非阻塞套接字**
- `shutdown` 是立即返回的操作，不关心发送缓冲区是否清空。
- 若需确保数据发送完成，可配合 `setsockopt(SO_LINGER)` 使用。


### **六、示例代码**
#### 1. **半关闭示例（文件传输）**
```c
// 客户端代码
send_file(sockfd, "data.txt");  // 发送文件
shutdown(sockfd, SHUT_WR);      // 关闭写通道，继续接收确认

// 接收服务器确认
while ((n = recv(sockfd, buffer, sizeof(buffer), 0)) > 0) {
    // 处理确认信息
}
close(sockfd);

// 服务器代码
while ((n = recv(sockfd, buffer, sizeof(buffer), 0)) > 0) {
    // 写入文件
}
// 客户端已关闭写通道，发送确认
send(sockfd, "OK", 2, 0);
close(sockfd);
```

#### 2. **优雅关闭示例**
```c
void graceful_shutdown(int sockfd) {
    // 关闭写通道，通知对方不再发送
    if (shutdown(sockfd, SHUT_WR) == -1) {
        perror("shutdown");
        return;
    }

    // 继续接收剩余数据
    char buffer[1024];
    while ((n = recv(sockfd, buffer, sizeof(buffer), 0)) > 0) {
        // 处理数据
    }

    // 对方也关闭后，关闭本地套接字
    close(sockfd);
}
```


### **七、总结**
| **特性**         | **`shutdown`**                 | **`close`**                    |
|------------------|--------------------------------|--------------------------------|
| **关闭方向**     | 可选择性关闭（读/写/读写）      | 同时关闭读写                   |
| **引用计数**     | 不影响引用计数                 | 减少引用计数，为0时关闭连接    |
| **发送缓冲区**   | 保证已排队数据被发送           | 可能丢弃未发送数据             |
| **半关闭支持**   | 支持（如 `SHUT_WR`）           | 不支持                         |
| **典型场景**     | 优雅关闭、半关闭连接           | 完全终止连接                   |

合理使用 `shutdown` 能显著提升网络应用的健壮性，尤其在需要精细控制连接状态的场景（如长连接服务、文件传输）中不可或缺。